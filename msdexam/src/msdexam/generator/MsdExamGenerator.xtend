/*
 * generated by Xtext 2.25.0
 */
package msdexam.generator

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import msdexam.msdExam.X21
import msdexam.msdExam.Function
import msdexam.msdExam.Plus
import msdexam.msdExam.Num
import msdexam.msdExam.Input
import msdexam.msdExam.Node
import msdexam.msdExam.Stream
import msdexam.msdExam.InputNNode
import msdexam.msdExam.Minus
import msdexam.msdExam.Mult
import msdexam.msdExam.Div
import msdexam.msdExam.Parameter
import msdexam.msdExam.Element
import msdexam.msdExam.Variable
import msdexam.msdExam.Parenthesis
import msdexam.msdExam.Exp
import msdexam.msdExam.Lambda
import msdexam.msdExam.Logical
import java.util.HashMap
import msdexam.msdExam.None
import msdexam.msdExam.New
import msdexam.msdExam.ObjectVariable
import msdexam.msdExam.Let
import org.eclipse.emf.common.util.EList
import java.util.ArrayList


/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class MsdExamGenerator extends AbstractGenerator {
	var counter = 0
	val HashMap<String, Integer> nameMap = new HashMap<String, Integer>();
	val ArrayList<Integer> letList = new ArrayList<Integer>();


	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		val program = resource.allContents.filter(X21).next
		fsa.generateFile(program.name.toFirstLower + "/" + program.name.toFirstUpper +"Main.java",generateFileContents(program))
	}
	
	def CharSequence generateFileContents(X21 program) {
		'''
		package «program.name.toFirstLower»;
		import libx21.*;
		import java.util.function.Function;
		import java.util.List;
		
		public class «program.name.toFirstUpper»Main extends GenericMainX21 {
			«generateParameters(program)»
			«generateFunctions(program)»
			«generateInputs(program)»
			«generateNodes(program)»
			«generateNodesForInternalLambdas(program)»
			«generateOutputNodes(program)»
			«generateHelperMethods(program)»
			«initializeNodes(program)»
			«initializeNetwork(program)»
		}
		'''
	}
	
	def CharSequence generateParameters(X21 program) {
		'''
		«FOR p: program.declarations.filter(Parameter)»
		private Integer _«p.name»;
		public void setParameter«p.name.toFirstUpper»(Integer value){
			_«p.name» = value;
		}
		«ENDFOR»
		
		'''
	}
	
	def CharSequence generateFunctions(X21 program) {
		'''
		
		«FOR f: program.declarations.filter(Function)»
		private Object fun_«f.name»(Object arg) {
			return funimpl_«f.name»((Integer)arg);
		}
		
		private Object funimpl_«f.name»(Integer _«f.function.id») { return («FOR exp: f.function.exps»«exp.getExpBody»«ENDFOR»); }
		«ENDFOR»
		
		'''
	}
	
	def CharSequence getExpBody(Exp exp){
		switch exp {
			Plus: "+"
			Minus: "-"
			Mult: "*"
			Div: "/"
			Variable: "(_" + exp.id +")"
			Num: "(" + exp.value.toString + ")"
			Parenthesis: "(" + exp.generateParenthesis + ")"
			Logical: "(" + exp.logical.left.getExpBody + exp.logical.logic + exp.logical.right.getExpBody + "?" + exp.then.getExpBody + ":" + exp.el.getExpBody + ")"
			Let: "let"+getCounter(true)  + exp.exps.loopExps 
			None: ""
			New: ""
			ObjectVariable:  ""
			default: exp.toString
		}
	}
	
	def CharSequence loopExps(EList<Exp> list){
		'''«FOR e:list»«e.getExpBody»«ENDFOR»'''
	}

	
	def CharSequence generateParenthesis(Parenthesis p) {
		'''«FOR e:p.exps»«e.getExpBody»«ENDFOR»'''
	}
	
	def CharSequence generateInputs(X21 program) {
		'''
		«FOR input: program.declarations.filter(Input)»
		private ComputeNode<Object, Object> node_«input.name» = new InputNode<Object>();
		public void input«input.name.toFirstUpper»(Integer input){
			node_«input.name».put(input);
		}
		
		«ENDFOR»
		'''
	}
	
	def CharSequence generateNodes(X21 program) {
		'''
		«FOR n: program.declarations.filter(Node)»
		private ComputeNode<Object, Object> node_«n.name» = new AbstractComputeNode<Object, Object>(){
			protected Object function(Object input) {
				return fun_«IF n.function !== null»«n.function.name»«ELSEIF n.lambda !== null»«n.lambda.id»«ENDIF»(input);
			}
		};
		
		«ENDFOR»
		'''
	}
	
	def CharSequence generateOutputNodes(X21 program) {
		'''
		«FOR s: program.declarations.filter(Stream)»
			«FOR func: s.functions»
				«IF func.output !== null»private OutputNode<Object> node_«func.output»  = new OutputNode<Object>();
				public List<Object> get«func.output.toFirstUpper»() {return node_«func.output».getData(); }
				«ENDIF»
			«ENDFOR»
		«ENDFOR»
		
		'''
	}
	
	def CharSequence initializeNodes(X21 program) {
		counter = 0
		'''
		protected void initializeNodes() {
			«FOR n:program.declarations.filter(InputNNode)»
			super.addNode(node_«n.name»);
			«ENDFOR»
			«FOR s:program.declarations.filter(Stream)»
			«FOR func:s.functions»
		«IF func.function instanceof Lambda»	super.addNode(node_«nameMap.get(func.function.toString)»); 
		«ELSEIF func.name !== null»	super.addNode(node_«nameMap.get(func.name)»);
			«ENDIF»                     
			«ENDFOR»
			«ENDFOR»
		}
		
		'''
	}
  
	def CharSequence initializeNetwork(X21 program) {
		'''
		protected void initializeNetwork() {
			«FOR s: program.declarations.filter(Stream)»
				«FOR i: s.inputs»
					«FOR f: s.functions»
					«IF f.output===null»node_«i.name».addOutputNode(node_«f.getNodeName»);«ENDIF»
					«ENDFOR»
				«ENDFOR»
				«FOR f: s.functions»
				«IF f.output !== null»
				«FOR f2: s.functions»
				«IF f !== f2 && f2.output === null»
				node_«f2.getNodeName».addOutputNode(node_«f.getNodeName»);
				«ENDIF»
				«ENDFOR»
				«ENDIF»
				«ENDFOR»	
			«ENDFOR»
		}
		
		'''
	}
	
	def CharSequence generateNodesForInternalLambdas(X21 program){
		'''
		«FOR s: program.declarations.filter(Stream)»
			«FOR func: s.functions»
				«IF func.function instanceof Lambda»private ComputeNode <Object,Object> node_«getCounter(false)» = new AbstractComputeNode<Object,Object>() {«addToMap(func.function.toString, getIntCounter-1)»
					protected Object function(Object input){
						Function<Integer,Object> f = (Integer _«func.function.id») -> { return «FOR exp: func.function.exps»«exp.getExpBody»«ENDFOR»; };
						return f.apply((Integer)input);
					}
				};
				«ELSEIF func.name !== null»private ComputeNode <Object,Object> node_«getCounter(false)» = new AbstractComputeNode<Object,Object>() { «addToMap(func.name, getIntCounter-1)»
					protected Object function(Object input){
						return fun_«func.name»(input);
					}
				};
				«ENDIF»
			«ENDFOR»
		«ENDFOR»
		
		'''
	}
	
	def CharSequence generateHelperMethods(X21 program){
		'''
		«FOR f: program.declarations.filter(Function)»
		«FOR e: f.function.exps»
		«IF e instanceof Let»
		private static int let«letList.get(0)»(int _«e.id») {
			return(«FOR b: e.body»«b.getExpBody»«ENDFOR»);
		}
		
		«ENDIF»
		«ENDFOR»
		«ENDFOR»
		'''
	}
	
	def CharSequence getNodeName(Element e){//getCounter is not always correct
		'''«IF e.funcNode !== null»«e.funcNode.name»«ELSEIF e.name !== null»«nameMap.get(e.name)»«ELSEIF e.function !== null»«nameMap.get(e.function.toString)»«ELSEIF e.output !== null»«e.output»«ENDIF»'''
	}
	
	def CharSequence getCounter(boolean isLet){
		counter = counter+1
		
		if(isLet) {
			addToLetList(counter)	
		}
		'''«counter-1»'''
	}
	
	def addToLetList(Integer i) {
		letList.add(i-1)
	}
	
	def Integer getIntCounter(){
		counter
	}
	
	def CharSequence getCounterNoInc(){
		'''«counter»'''
	}
	
	def String name(InputNNode node){
		switch node{
			Input: node.name
			Node: node.name
		}
	}
	
	def void addToMap(String s, Integer i){
		nameMap.put(s, i)
	}
}
